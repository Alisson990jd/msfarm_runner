name: Microsoft Rewards Bot

on:
  workflow_dispatch:
    inputs:
      password:
        description: 'Senha de execu√ß√£o'
        required: true
        type: string
      action:
        description: 'A√ß√£o a executar'
        required: true
        default: 'run'
        type: choice
        options:
          - run
          - test

env:
  WORK_DIR: /home/runner/work/msfarm

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      valid: ${{ steps.check.outputs.valid }}
    steps:
      - name: Validar senha
        id: check
        run: |
          if [ "${{ github.event.inputs.password }}" = "${{ secrets.PASS }}" ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Senha v√°lida!"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "‚ùå Senha incorreta!"
            exit 1
          fi

  setup-and-run:
    needs: validate
    if: needs.validate.outputs.valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 horas m√°ximo
    
    steps:
      - name: üì¶ Checkout do reposit√≥rio atual
        uses: actions/checkout@v4

      - name: üêç Configurar Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: üì• Baixar arquivos do reposit√≥rio msfarm
        env:
          GH_TOKEN: ${{ secrets.GH_API_TOKEN }}
        run: |
          mkdir -p ${{ env.WORK_DIR }}
          cd ${{ env.WORK_DIR }}
          
          echo "üì• Baixando arquivos da pasta msfarm..."
          
          # Listar arquivos na pasta msfarm
          FILES=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/Alisson990jd/apiss/contents/msfarm?ref=main")
          
          # Baixar cada arquivo
          echo "$FILES" | jq -r '.[] | select(.type=="file") | .name + " " + .download_url' | while read name url; do
            echo "  üìÑ Baixando: $name"
            curl -s -H "Authorization: token $GH_TOKEN" -L "$url" -o "$name"
          done
          
          # Baixar pasta pkl se existir
          PKL_EXISTS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/Alisson990jd/apiss/contents/msfarm/pkl?ref=main")
          
          if [ "$PKL_EXISTS" = "200" ]; then
            echo "üì• Baixando pasta pkl..."
            mkdir -p pkl
            PKL_FILES=$(curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/Alisson990jd/apiss/contents/msfarm/pkl?ref=main")
            
            echo "$PKL_FILES" | jq -r '.[] | select(.type=="file") | .name + " " + .download_url' | while read name url; do
              echo "  üìÑ Baixando pkl: $name"
              curl -s -H "Authorization: token $GH_TOKEN" -L "$url" -o "pkl/$name"
            done
          fi
          
          echo "‚úÖ Download conclu√≠do!"
          ls -la

      - name: üìã Criar requirements.txt
        run: |
          cat > ${{ env.WORK_DIR }}/requirements.txt << 'EOF'
          # Discord Bot
          discord.py
          aiohttp
          
          # Playwright e automa√ß√£o
          playwright
          playwright-stealth
          
          # Google API (Gmail)
          google-api-python-client
          google-auth
          google-auth-oauthlib
          google-auth-httplib2
          
          # Utilit√°rios
          httplib2
          EOF
          
          cat ${{ env.WORK_DIR }}/requirements.txt

      - name: üì¶ Instalar depend√™ncias Python
        run: |
          cd ${{ env.WORK_DIR }}
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: üé≠ Instalar navegadores do Playwright
        run: |
          playwright install chromium
          playwright install-deps chromium

      - name: üñ•Ô∏è Instalar Xvfb e depend√™ncias de display
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            xvfb \
            x11-utils \
            libxcomposite1 \
            libxdamage1 \
            libxrandr2 \
            libgbm1 \
            libpango-1.0-0 \
            libcairo2 \
            libasound2 \
            libatspi2.0-0 \
            libcups2 \
            libdrm2 \
            libxshmfence1 \
            fonts-liberation \
            fonts-noto-color-emoji

      - name: üîß Modificar start.py para usar secrets
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CHANNEL_ID: ${{ secrets.DISCORD_CHANNEL_ID }}
          GH_API_TOKEN: ${{ secrets.GH_API_TOKEN }}
        run: |
          cd ${{ env.WORK_DIR }}
          
          # Criar script modificado
          cat > start_modified.py << 'PYTHON_SCRIPT'
          #!/usr/bin/env python3
          """
          C√©rebro Central - Bot Discord para automa√ß√£o de execu√ß√£o de emails
          Vers√£o modificada para usar vari√°veis de ambiente
          """

          import discord
          from discord.ext import commands, tasks
          import asyncio
          import aiohttp
          import json
          import os
          import subprocess
          import base64
          from datetime import datetime, timedelta
          from collections import deque
          import logging
          import signal
          import sys

          # ==================== CONFIGURA√á√ïES VIA VARI√ÅVEIS DE AMBIENTE ====================

          DISCORD_TOKEN = os.environ.get("DISCORD_TOKEN")
          CHANNEL_ID = int(os.environ.get("DISCORD_CHANNEL_ID", "0"))
          GITHUB_TOKEN = os.environ.get("GH_API_TOKEN")
          GITHUB_REPO = "Alisson990jd/apiss"
          GITHUB_BRANCH = "main"
          GITHUB_PATH = "msfarm"

          # Validar vari√°veis obrigat√≥rias
          if not DISCORD_TOKEN:
              print("‚ùå ERRO: DISCORD_TOKEN n√£o definido!")
              sys.exit(1)
          if not CHANNEL_ID:
              print("‚ùå ERRO: DISCORD_CHANNEL_ID n√£o definido!")
              sys.exit(1)
          if not GITHUB_TOKEN:
              print("‚ùå ERRO: GH_API_TOKEN n√£o definido!")
              sys.exit(1)

          MAX_CONCURRENT = 4  # Execu√ß√µes simult√¢neas
          SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
          EMAILS_FILE = os.path.join(SCRIPT_DIR, "emails.txt")
          USAGE_FILE = os.path.join(SCRIPT_DIR, "emails_usage.json")
          YT_SCRIPT = os.path.join(SCRIPT_DIR, "yt.py")

          # ==================== LOGGING ====================

          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s [%(levelname)s] %(message)s',
              handlers=[
                  logging.FileHandler('cerebro.log'),
                  logging.StreamHandler()
              ]
          )
          logger = logging.getLogger(__name__)

          # ==================== CLASSES PRINCIPAIS ====================

          class GitHubManager:
              """Gerencia sincroniza√ß√£o com GitHub"""
              
              def __init__(self, token, repo, branch, path):
                  self.token = token
                  self.repo = repo
                  self.branch = branch
                  self.path = path
                  self.base_url = f"https://api.github.com/repos/{repo}/contents/{path}"
                  self.headers = {
                      "Authorization": f"token {token}",
                      "Accept": "application/vnd.github.v3+json"
                  }
              
              async def get_file(self, filename):
                  """Baixa um arquivo do GitHub"""
                  url = f"{self.base_url}/{filename}?ref={self.branch}"
                  async with aiohttp.ClientSession() as session:
                      async with session.get(url, headers=self.headers) as response:
                          if response.status == 200:
                              data = await response.json()
                              content = base64.b64decode(data['content']).decode('utf-8')
                              return content, data['sha']
                          elif response.status == 404:
                              return None, None
                          else:
                              raise Exception(f"Erro ao baixar {filename}: {response.status}")
              
              async def update_file(self, filename, content, sha=None, message="Update via bot"):
                  """Atualiza ou cria um arquivo no GitHub"""
                  url = f"{self.base_url}/{filename}"
                  
                  # Se n√£o temos SHA, tentar obter
                  if sha is None:
                      _, sha = await self.get_file(filename)
                  
                  payload = {
                      "message": message,
                      "content": base64.b64encode(content.encode('utf-8')).decode('utf-8'),
                      "branch": self.branch
                  }
                  
                  if sha:
                      payload["sha"] = sha
                  
                  async with aiohttp.ClientSession() as session:
                      async with session.put(url, headers=self.headers, json=payload) as response:
                          if response.status in [200, 201]:
                              data = await response.json()
                              return data['content']['sha']
                          else:
                              error = await response.text()
                              raise Exception(f"Erro ao atualizar {filename}: {response.status} - {error}")


          class EmailManager:
              """Gerencia emails e seus estados"""
              
              def __init__(self, github_manager):
                  self.github = github_manager
                  self.emails = []
                  self.usage = {}
                  self.emails_sha = None
                  self.usage_sha = None
                  self.lock = asyncio.Lock()
              
              async def sync_from_github(self):
                  """Sincroniza arquivos do GitHub para local"""
                  async with self.lock:
                      try:
                          # Baixar emails.txt
                          content, sha = await self.github.get_file("emails.txt")
                          if content:
                              self.emails = [e.strip() for e in content.strip().split('\n') if e.strip()]
                              self.emails_sha = sha
                              
                              # Salvar localmente
                              with open(EMAILS_FILE, 'w') as f:
                                  f.write('\n'.join(self.emails))
                          else:
                              self.emails = []
                          
                          # Baixar emails_usage.json
                          content, sha = await self.github.get_file("emails_usage.json")
                          if content:
                              self.usage = json.loads(content)
                              self.usage_sha = sha
                              
                              # Salvar localmente
                              with open(USAGE_FILE, 'w') as f:
                                  json.dump(self.usage, f, indent=2)
                          else:
                              self.usage = {}
                          
                          logger.info(f"Sincronizado: {len(self.emails)} emails, {len(self.usage)} registros de uso")
                          return True
                          
                      except Exception as e:
                          logger.error(f"Erro ao sincronizar do GitHub: {e}")
                          
                          # Tentar carregar localmente
                          if os.path.exists(EMAILS_FILE):
                              with open(EMAILS_FILE, 'r') as f:
                                  self.emails = [e.strip() for e in f.read().strip().split('\n') if e.strip()]
                          
                          if os.path.exists(USAGE_FILE):
                              with open(USAGE_FILE, 'r') as f:
                                  self.usage = json.load(f)
                          
                          return False
              
              async def sync_to_github(self, update_emails=True, update_usage=True):
                  """Sincroniza arquivos locais para o GitHub"""
                  async with self.lock:
                      try:
                          if update_emails:
                              content = '\n'.join(self.emails)
                              self.emails_sha = await self.github.update_file(
                                  "emails.txt", 
                                  content, 
                                  self.emails_sha,
                                  f"Update emails.txt - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                              )
                              
                              # Salvar localmente
                              with open(EMAILS_FILE, 'w') as f:
                                  f.write(content)
                          
                          if update_usage:
                              content = json.dumps(self.usage, indent=2)
                              self.usage_sha = await self.github.update_file(
                                  "emails_usage.json", 
                                  content, 
                                  self.usage_sha,
                                  f"Update usage - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                              )
                              
                              # Salvar localmente
                              with open(USAGE_FILE, 'w') as f:
                                  f.write(content)
                          
                          logger.info("Sincronizado para GitHub com sucesso")
                          return True
                          
                      except Exception as e:
                          logger.error(f"Erro ao sincronizar para GitHub: {e}")
                          return False
              
              async def add_email(self, email):
                  """Adiciona um email"""
                  async with self.lock:
                      if email not in self.emails:
                          self.emails.append(email)
                          logger.info(f"Email adicionado: {email}")
                          return True
                      return False
              
              async def remove_email(self, email):
                  """Remove um email"""
                  async with self.lock:
                      if email in self.emails:
                          self.emails.remove(email)
                          logger.info(f"Email removido: {email}")
                          return True
                      return False
              
              async def mark_executed(self, email, success=True, error_msg=None):
                  """Marca um email como executado hoje"""
                  async with self.lock:
                      today = datetime.now().strftime('%Y-%m-%d')
                      
                      if email not in self.usage:
                          self.usage[email] = {
                              "executions": [],
                              "total_success": 0,
                              "total_failed": 0
                          }
                      
                      execution = {
                          "date": today,
                          "time": datetime.now().strftime('%H:%M:%S'),
                          "success": success,
                          "error": error_msg
                      }
                      
                      self.usage[email]["executions"].append(execution)
                      
                      if success:
                          self.usage[email]["total_success"] += 1
                      else:
                          self.usage[email]["total_failed"] += 1
                      
                      # Manter apenas √∫ltimas 30 execu√ß√µes
                      self.usage[email]["executions"] = self.usage[email]["executions"][-30:]
              
              def get_pending_today(self):
                  """Retorna emails que ainda n√£o foram executados hoje"""
                  today = datetime.now().strftime('%Y-%m-%d')
                  pending = []
                  
                  for email in self.emails:
                      if email not in self.usage:
                          pending.append(email)
                          continue
                      
                      executions = self.usage[email].get("executions", [])
                      
                      # Verificar se j√° executou hoje com sucesso
                      executed_today = False
                      for ex in executions:
                          if ex.get("date") == today and ex.get("success"):
                              executed_today = True
                              break
                      
                      if not executed_today:
                          pending.append(email)
                  
                  return pending


          class ExecutionManager:
              """Gerencia a execu√ß√£o dos scripts"""
              
              def __init__(self, email_manager, bot):
                  self.email_manager = email_manager
                  self.bot = bot
                  self.semaphore = asyncio.Semaphore(MAX_CONCURRENT)
                  self.running = False
                  self.queue = deque()
                  self.active_tasks = {}
                  self.display_counter = 0
                  self.display_lock = asyncio.Lock()
              
              async def get_next_display(self):
                  """Obt√©m pr√≥ximo n√∫mero de display dispon√≠vel"""
                  async with self.display_lock:
                      self.display_counter += 1
                      return self.display_counter + 99  # Come√ßa do display :100
              
              async def execute_email(self, email, display_num):
                  """Executa o script para um email espec√≠fico"""
                  start_time = datetime.now()
                  
                  try:
                      await self.send_notification(f"üîÑ **Iniciando execu√ß√£o**\nüìß Email: `{email}`\nüñ•Ô∏è Display: :{display_num}")
                      
                      # Comando para executar com Xvfb
                      cmd = f"""
                      export DISPLAY=:{display_num}
                      Xvfb :{display_num} -screen 0 1920x1080x24 &
                      XVFB_PID=$!
                      sleep 2
                      
                      cd {SCRIPT_DIR}
                      python3 {YT_SCRIPT} -email {email}
                      EXIT_CODE=$?
                      
                      kill $XVFB_PID 2>/dev/null
                      exit $EXIT_CODE
                      """
                      
                      process = await asyncio.create_subprocess_shell(
                          cmd,
                          stdout=asyncio.subprocess.PIPE,
                          stderr=asyncio.subprocess.PIPE,
                          cwd=SCRIPT_DIR
                      )
                      
                      stdout, stderr = await process.communicate()
                      
                      duration = (datetime.now() - start_time).total_seconds()
                      duration_str = f"{int(duration // 60)}m {int(duration % 60)}s"
                      
                      if process.returncode == 0:
                          await self.email_manager.mark_executed(email, success=True)
                          await self.email_manager.sync_to_github(update_emails=False, update_usage=True)
                          
                          await self.send_notification(
                              f"‚úÖ **Execu√ß√£o conclu√≠da com SUCESSO**\n"
                              f"üìß Email: `{email}`\n"
                              f"‚è±Ô∏è Dura√ß√£o: {duration_str}\n"
                              f"üñ•Ô∏è Display: :{display_num}"
                          )
                          
                          return True
                      else:
                          error_msg = stderr.decode('utf-8')[-500:] if stderr else "Erro desconhecido"
                          await self.email_manager.mark_executed(email, success=False, error_msg=error_msg)
                          await self.email_manager.sync_to_github(update_emails=False, update_usage=True)
                          
                          await self.send_notification(
                              f"‚ùå **Execu√ß√£o FALHOU**\n"
                              f"üìß Email: `{email}`\n"
                              f"‚è±Ô∏è Dura√ß√£o: {duration_str}\n"
                              f"üñ•Ô∏è Display: :{display_num}\n"
                              f"üìù Erro: ```{error_msg[:200]}```"
                          )
                          
                          return False
                          
                  except Exception as e:
                      logger.error(f"Erro ao executar {email}: {e}")
                      await self.email_manager.mark_executed(email, success=False, error_msg=str(e))
                      await self.send_notification(
                          f"‚ùå **Erro de execu√ß√£o**\n"
                          f"üìß Email: `{email}`\n"
                          f"üìù Erro: ```{str(e)[:200]}```"
                      )
                      return False
              
              async def worker(self, email):
                  """Worker que processa um email"""
                  async with self.semaphore:
                      display_num = await self.get_next_display()
                      try:
                          await self.execute_email(email, display_num)
                      finally:
                          if email in self.active_tasks:
                              del self.active_tasks[email]
              
              async def run_daily_batch(self):
                  """Executa batch di√°rio de todos os emails pendentes"""
                  await self.email_manager.sync_from_github()
                  pending = self.email_manager.get_pending_today()
                  
                  if not pending:
                      await self.send_notification("‚ÑπÔ∏è **Nenhum email pendente para execu√ß√£o hoje!**")
                      return
                  
                  await self.send_notification(
                      f"üöÄ **Iniciando batch di√°rio**\n"
                      f"üìä Total de emails: {len(pending)}\n"
                      f"‚ö° Execu√ß√µes paralelas: {MAX_CONCURRENT}"
                  )
                  
                  self.running = True
                  self.display_counter = 0
                  
                  tasks = []
                  for email in pending:
                      task = asyncio.create_task(self.worker(email))
                      self.active_tasks[email] = task
                      tasks.append(task)
                  
                  await asyncio.gather(*tasks, return_exceptions=True)
                  
                  self.running = False
                  
                  # Estat√≠sticas finais
                  successful = sum(1 for e in pending if self.email_manager.usage.get(e, {}).get("executions", [{}])[-1].get("success", False))
                  failed = len(pending) - successful
                  
                  await self.send_notification(
                      f"üèÅ **Batch di√°rio conclu√≠do!**\n"
                      f"‚úÖ Sucesso: {successful}\n"
                      f"‚ùå Falhas: {failed}\n"
                      f"üìä Total: {len(pending)}"
                  )
              
              async def send_notification(self, message):
                  """Envia notifica√ß√£o para o canal do Discord"""
                  try:
                      channel = self.bot.get_channel(CHANNEL_ID)
                      if channel:
                          await channel.send(message)
                      else:
                          logger.warning(f"Canal {CHANNEL_ID} n√£o encontrado")
                  except Exception as e:
                      logger.error(f"Erro ao enviar notifica√ß√£o: {e}")


          # ==================== BOT DISCORD ====================

          intents = discord.Intents.default()
          intents.message_content = True

          bot = commands.Bot(command_prefix='!', intents=intents)

          # Managers globais
          github_manager = None
          email_manager = None
          execution_manager = None


          @bot.event
          async def on_ready():
              global github_manager, email_manager, execution_manager
              
              logger.info(f"Bot conectado como {bot.user}")
              
              # Inicializar managers
              github_manager = GitHubManager(GITHUB_TOKEN, GITHUB_REPO, GITHUB_BRANCH, GITHUB_PATH)
              email_manager = EmailManager(github_manager)
              execution_manager = ExecutionManager(email_manager, bot)
              
              # Sincronizar do GitHub
              await email_manager.sync_from_github()
              
              channel = bot.get_channel(CHANNEL_ID)
              if channel:
                  embed = discord.Embed(
                      title="üß† C√©rebro Central Online!",
                      description="Sistema de automa√ß√£o iniciado com sucesso.",
                      color=discord.Color.green(),
                      timestamp=datetime.now()
                  )
                  embed.add_field(name="üìß Emails carregados", value=str(len(email_manager.emails)), inline=True)
                  embed.add_field(name="‚ö° Execu√ß√µes paralelas", value=str(MAX_CONCURRENT), inline=True)
                  embed.add_field(
                      name="üìù Comandos dispon√≠veis",
                      value=(
                          "`!add email@email.com` - Adicionar email\n"
                          "`!remove email@email.com` - Remover email\n"
                          "`!list` - Listar emails\n"
                          "`!status` - Ver status\n"
                          "`!run` - Executar batch manual\n"
                          "`!pending` - Ver pendentes\n"
                          "`!sync` - Sincronizar com GitHub\n"
                          "`!stop` - Parar execu√ß√µes"
                      ),
                      inline=False
                  )
                  await channel.send(embed=embed)
              
              # Iniciar task de execu√ß√£o di√°ria
              daily_task.start()


          @bot.command(name='add')
          async def add_email(ctx, email: str):
              """Adiciona um email √† lista"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              if not email or '@' not in email:
                  await ctx.send("‚ùå Email inv√°lido!")
                  return
              
              if await email_manager.add_email(email):
                  await email_manager.sync_to_github(update_emails=True, update_usage=False)
                  await ctx.send(f"‚úÖ Email adicionado: `{email}`\nüìä Total de emails: {len(email_manager.emails)}")
              else:
                  await ctx.send(f"‚ö†Ô∏è Email j√° existe: `{email}`")


          @bot.command(name='remove')
          async def remove_email(ctx, email: str):
              """Remove um email da lista"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              if await email_manager.remove_email(email):
                  await email_manager.sync_to_github(update_emails=True, update_usage=False)
                  await ctx.send(f"‚úÖ Email removido: `{email}`\nüìä Total de emails: {len(email_manager.emails)}")
              else:
                  await ctx.send(f"‚ö†Ô∏è Email n√£o encontrado: `{email}`")


          @bot.command(name='list')
          async def list_emails(ctx):
              """Lista todos os emails"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              if not email_manager.emails:
                  await ctx.send("üì≠ Nenhum email cadastrado.")
                  return
              
              # Dividir em chunks se muitos emails
              emails_text = "\n".join([f"‚Ä¢ `{e}`" for e in email_manager.emails])
              
              embed = discord.Embed(
                  title="üìß Lista de Emails",
                  description=emails_text[:4000],
                  color=discord.Color.blue()
              )
              embed.set_footer(text=f"Total: {len(email_manager.emails)} emails")
              await ctx.send(embed=embed)


          @bot.command(name='status')
          async def status(ctx):
              """Mostra status atual"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              today = datetime.now().strftime('%Y-%m-%d')
              pending = email_manager.get_pending_today()
              
              # Contar executados hoje
              executed_today = 0
              success_today = 0
              for email in email_manager.emails:
                  usage = email_manager.usage.get(email, {})
                  for ex in usage.get("executions", []):
                      if ex.get("date") == today:
                          executed_today += 1
                          if ex.get("success"):
                              success_today += 1
              
              embed = discord.Embed(
                  title="üìä Status do Sistema",
                  color=discord.Color.purple(),
                  timestamp=datetime.now()
              )
              embed.add_field(name="üìß Total de emails", value=str(len(email_manager.emails)), inline=True)
              embed.add_field(name="‚è≥ Pendentes hoje", value=str(len(pending)), inline=True)
              embed.add_field(name="‚úÖ Executados hoje", value=f"{success_today}/{executed_today}", inline=True)
              embed.add_field(name="üîÑ Em execu√ß√£o", value=str(len(execution_manager.active_tasks)), inline=True)
              embed.add_field(name="‚ö° Status", value="üü¢ Ativo" if execution_manager.running else "üîµ Idle", inline=True)
              
              await ctx.send(embed=embed)


          @bot.command(name='pending')
          async def pending(ctx):
              """Mostra emails pendentes para hoje"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              pending = email_manager.get_pending_today()
              
              if not pending:
                  await ctx.send("‚úÖ Todos os emails j√° foram executados hoje!")
                  return
              
              emails_text = "\n".join([f"‚Ä¢ `{e}`" for e in pending[:50]])
              
              embed = discord.Embed(
                  title="‚è≥ Emails Pendentes Hoje",
                  description=emails_text[:4000],
                  color=discord.Color.orange()
              )
              embed.set_footer(text=f"Total pendente: {len(pending)} emails")
              await ctx.send(embed=embed)


          @bot.command(name='run')
          async def run_manual(ctx):
              """Executa batch manual"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              if execution_manager.running:
                  await ctx.send("‚ö†Ô∏è J√° existe uma execu√ß√£o em andamento!")
                  return
              
              await ctx.send("üöÄ Iniciando execu√ß√£o manual...")
              asyncio.create_task(execution_manager.run_daily_batch())


          @bot.command(name='sync')
          async def sync(ctx):
              """Sincroniza com GitHub"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              await ctx.send("üîÑ Sincronizando com GitHub...")
              
              if await email_manager.sync_from_github():
                  await ctx.send(f"‚úÖ Sincronizado! {len(email_manager.emails)} emails carregados.")
              else:
                  await ctx.send("‚ö†Ô∏è Erro ao sincronizar, usando dados locais.")


          @bot.command(name='stop')
          async def stop(ctx):
              """Para execu√ß√µes em andamento"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              if not execution_manager.active_tasks:
                  await ctx.send("‚ÑπÔ∏è Nenhuma execu√ß√£o em andamento.")
                  return
              
              # Cancelar todas as tasks
              for email, task in execution_manager.active_tasks.items():
                  task.cancel()
              
              execution_manager.running = False
              await ctx.send(f"üõë {len(execution_manager.active_tasks)} execu√ß√µes canceladas.")


          @bot.command(name='history')
          async def history(ctx, email: str = None):
              """Mostra hist√≥rico de execu√ß√µes"""
              if ctx.channel.id != CHANNEL_ID:
                  return
              
              if email:
                  usage = email_manager.usage.get(email, {})
                  if not usage:
                      await ctx.send(f"üì≠ Nenhum hist√≥rico para `{email}`")
                      return
                  
                  executions = usage.get("executions", [])[-10:]
                  history_text = ""
                  for ex in executions:
                      status = "‚úÖ" if ex.get("success") else "‚ùå"
                      history_text += f"{status} {ex.get('date')} {ex.get('time')}\n"
                  
                  embed = discord.Embed(
                      title=f"üìú Hist√≥rico: {email}",
                      description=history_text or "Sem execu√ß√µes",
                      color=discord.Color.blue()
                  )
                  embed.add_field(name="‚úÖ Sucessos", value=str(usage.get("total_success", 0)), inline=True)
                  embed.add_field(name="‚ùå Falhas", value=str(usage.get("total_failed", 0)), inline=True)
                  await ctx.send(embed=embed)
              else:
                  await ctx.send("‚ùì Use: `!history email@email.com`")


          @tasks.loop(hours=24)
          async def daily_task():
              """Task de execu√ß√£o di√°ria autom√°tica"""
              await asyncio.sleep(5)  # Pequeno delay inicial
              
              # Executar √†s 07:00
              now = datetime.now()
              target = now.replace(hour=7, minute=0, second=0, microsecond=0)
              
              if now > target:
                  target += timedelta(days=1)
              
              wait_seconds = (target - now).total_seconds()
              logger.info(f"Pr√≥xima execu√ß√£o di√°ria em {wait_seconds/3600:.2f} horas")
              
              await asyncio.sleep(wait_seconds)
              
              channel = bot.get_channel(CHANNEL_ID)
              if channel:
                  await channel.send("‚è∞ **Execu√ß√£o di√°ria autom√°tica iniciando...**")
              
              await execution_manager.run_daily_batch()


          @daily_task.before_loop
          async def before_daily_task():
              """Aguarda o bot estar pronto"""
              await bot.wait_until_ready()


          @bot.event
          async def on_command_error(ctx, error):
              """Tratamento de erros de comandos"""
              if isinstance(error, commands.MissingRequiredArgument):
                  await ctx.send(f"‚ùå Argumento faltando: `{error.param}`")
              elif isinstance(error, commands.CommandNotFound):
                  pass  # Ignorar comandos n√£o encontrados
              else:
                  logger.error(f"Erro no comando: {error}")
                  await ctx.send(f"‚ùå Erro: {str(error)[:200]}")


          # ==================== MAIN ====================

          def signal_handler(sig, frame):
              """Handler para SIGINT/SIGTERM"""
              logger.info("Recebido sinal de encerramento...")
              asyncio.create_task(bot.close())
              sys.exit(0)


          if __name__ == "__main__":
              signal.signal(signal.SIGINT, signal_handler)
              signal.signal(signal.SIGTERM, signal_handler)
              
              logger.info("Iniciando C√©rebro Central...")
              logger.info(f"Canal ID: {CHANNEL_ID}")
              logger.info(f"GitHub Repo: {GITHUB_REPO}")
              
              try:
                  bot.run(DISCORD_TOKEN)
              except KeyboardInterrupt:
                  logger.info("Encerrado pelo usu√°rio")
              except Exception as e:
                  logger.error(f"Erro fatal: {e}")
                  sys.exit(1)
          PYTHON_SCRIPT
          
          # Substituir o original pelo modificado
          mv start_modified.py start.py
          echo "‚úÖ start.py modificado para usar vari√°veis de ambiente"

      - name: üìã Verificar arquivos baixados
        run: |
          cd ${{ env.WORK_DIR }}
          echo "üìÅ Conte√∫do do diret√≥rio de trabalho:"
          ls -la
          echo ""
          echo "üìÅ Conte√∫do da pasta pkl (se existir):"
          ls -la pkl/ 2>/dev/null || echo "Pasta pkl n√£o encontrada"

      - name: üöÄ Executar Bot
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          DISCORD_CHANNEL_ID: ${{ secrets.DISCORD_CHANNEL_ID }}
          GH_API_TOKEN: ${{ secrets.GH_API_TOKEN }}
          DISPLAY: ":99"
        run: |
          cd ${{ env.WORK_DIR }}
          
          # Iniciar Xvfb principal
          echo "üñ•Ô∏è Iniciando Xvfb..."
          Xvfb :99 -screen 0 1920x1080x24 &
          sleep 3
          
          echo "üöÄ Iniciando bot..."
          python3 start.py

  notify-failure:
    needs: [validate, setup-and-run]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: ‚ùå Notificar falha
        run: |
          echo "‚ùå Workflow falhou!"
          echo "Verifique os logs acima para mais detalhes."
